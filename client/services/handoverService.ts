/**
 * Handover Service
 * Handles saving user handover data to Supabase handover_yacht table
 * Uses ORIGINAL schema: system_affected, fault_code, symptoms, actions_taken, duration_minutes, notes
 */

import { supabase } from '../lib/supabase';

export interface EntityPair {
  key: string;
  value: string;
}

export interface HandoverPayload {
  user_id: string;                    // Required: UUID from auth
  yacht_id: string;                   // Required: Yacht identifier
  document_source?: 'nas' | 'email' | 'manual';  // Source type
  document_name?: string;             // Optional: Document filename or email subject
  document_path?: string;             // Optional: HTTP path to document or email link
  document_page?: number;             // Optional: Page number (for NAS docs only)

  // New flexible entity fields (JSONB)
  entity_0?: EntityPair;              // Generic key-value pair
  entity_1?: EntityPair;              // Generic key-value pair
  entity_2?: EntityPair;              // Generic key-value pair
  entity_3?: EntityPair;              // Generic key-value pair
  entity_4?: EntityPair;              // Generic key-value pair
  entity_5?: EntityPair;              // Generic key-value pair

  notes?: string;                     // Additional notes (TEXT)
  status?: 'draft' | 'completed' | 'archived';  // Optional: defaults to 'draft'
}

export interface HandoverResponse {
  success: boolean;
  data?: any;
  error?: string;
}

/**
 * Save or update handover to Supabase
 * handover_id is auto-generated by Supabase (UUID)
 */
export async function saveHandover(payload: HandoverPayload): Promise<HandoverResponse> {
  try {
    // Get the authenticated user's ID from Supabase session
    const { data: { session } } = await supabase.auth.getSession();

    if (!session?.user) {
      return { success: false, error: 'User not authenticated. Please log in.' };
    }

    // Use the authenticated user's ID (this will match auth.uid() in RLS)
    const authenticatedUserId = session.user.id;

    // Validate required fields
    if (!payload.yacht_id) {
      return { success: false, error: 'yacht_id is required' };
    }

    // Prepare payload with new schema
    const handoverData: any = {
      user_id: authenticatedUserId, // Always use the authenticated user's ID
      yacht_id: payload.yacht_id,
      document_source: payload.document_source || 'manual',
      document_name: payload.document_name || null,
      document_path: payload.document_path || null,
      document_page: payload.document_page || null,
      entity_0: payload.entity_0 || null,
      entity_1: payload.entity_1 || null,
      entity_2: payload.entity_2 || null,
      entity_3: payload.entity_3 || null,
      entity_4: payload.entity_4 || null,
      entity_5: payload.entity_5 || null,
      notes: payload.notes || null,
      status: payload.status || 'draft'
    };

    console.log('üì§ Saving handover to Supabase:', {
      ...handoverData,
      user_id: handoverData.user_id,
      authenticated_user: session.user.email // Show who is authenticated
    });

    // INSERT new handover
    const { data, error } = await supabase
      .from('handover_yacht')
      .insert(handoverData)
      .select();

    if (error) {
      console.error('‚ùå Supabase error saving handover:', error);
      return {
        success: false,
        error: error.message
      };
    }

    console.log('‚úÖ Handover saved to Supabase:', data);
    return {
      success: true,
      data
    };

  } catch (error) {
    console.error('‚ùå Error in saveHandover:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Fetch handovers for the authenticated user
 */
export async function getHandovers(
  userId?: string, // Keep for backward compatibility, but will be ignored
  yachtId?: string,
  status?: 'draft' | 'completed' | 'archived'
): Promise<HandoverResponse> {
  try {
    // Get the authenticated user's ID from Supabase session
    const { data: { session } } = await supabase.auth.getSession();

    if (!session?.user) {
      return { success: false, error: 'User not authenticated. Please log in.' };
    }

    const authenticatedUserId = session.user.id;

    let query = supabase
      .from('handover_yacht')
      .select('*')
      .eq('user_id', authenticatedUserId) // Always use authenticated user
      .order('created_at', { ascending: false });

    if (yachtId) {
      query = query.eq('yacht_id', yachtId);
    }

    if (status) {
      query = query.eq('status', status);
    }

    const { data, error } = await query;

    if (error) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: true,
      data
    };

  } catch (error) {
    console.error('‚ùå Error in getHandovers:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Mark handover as completed
 */
export async function completeHandover(handoverId: string): Promise<HandoverResponse> {
  try {
    const { data, error } = await supabase
      .from('handover_yacht')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString()
      })
      .eq('handover_id', handoverId)
      .select();

    if (error) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: true,
      data
    };

  } catch (error) {
    console.error('‚ùå Error in completeHandover:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Generate or retrieve session ID (for tracking conversation context)
 */
export function getOrCreateSessionId(): string {
  const STORAGE_KEY = 'celesteos_session_id';

  let sessionId = localStorage.getItem(STORAGE_KEY);

  if (!sessionId) {
    sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem(STORAGE_KEY, sessionId);
  }

  return sessionId;
}

/**
 * Clear session ID
 */
export function clearSessionId(): void {
  localStorage.removeItem('celesteos_session_id');
}

/**
 * Delete handover entry
 */
export async function deleteHandover(handoverId: string): Promise<HandoverResponse> {
  try {
    const { data, error } = await supabase
      .from('handover_yacht')
      .delete()
      .eq('handover_id', handoverId)
      .select();

    if (error) {
      console.error('‚ùå Supabase error deleting handover:', error);
      return {
        success: false,
        error: error.message
      };
    }

    console.log('‚úÖ Handover deleted from Supabase:', data);
    return {
      success: true,
      data
    };

  } catch (error) {
    console.error('‚ùå Error in deleteHandover:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Update handover entry
 */
export async function updateHandover(
  handoverId: string,
  payload: Partial<HandoverPayload>
): Promise<HandoverResponse> {
  try {
    // Prepare update payload (only update provided fields)
    const updateData: any = {};

    if (payload.document_source !== undefined) updateData.document_source = payload.document_source;
    if (payload.document_name !== undefined) updateData.document_name = payload.document_name;
    if (payload.document_path !== undefined) updateData.document_path = payload.document_path;
    if (payload.document_page !== undefined) updateData.document_page = payload.document_page;
    if (payload.entity_0 !== undefined) updateData.entity_0 = payload.entity_0;
    if (payload.entity_1 !== undefined) updateData.entity_1 = payload.entity_1;
    if (payload.entity_2 !== undefined) updateData.entity_2 = payload.entity_2;
    if (payload.entity_3 !== undefined) updateData.entity_3 = payload.entity_3;
    if (payload.entity_4 !== undefined) updateData.entity_4 = payload.entity_4;
    if (payload.entity_5 !== undefined) updateData.entity_5 = payload.entity_5;
    if (payload.notes !== undefined) updateData.notes = payload.notes;
    if (payload.status !== undefined) updateData.status = payload.status;

    console.log('üì§ Updating handover in Supabase:', {
      handoverId,
      updateData
    });

    const { data, error } = await supabase
      .from('handover_yacht')
      .update(updateData)
      .eq('handover_id', handoverId)
      .select();

    if (error) {
      console.error('‚ùå Supabase error updating handover:', error);
      return {
        success: false,
        error: error.message
      };
    }

    console.log('‚úÖ Handover updated in Supabase:', data);
    return {
      success: true,
      data
    };

  } catch (error) {
    console.error('‚ùå Error in updateHandover:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Submit handover to webhook (for "Add to Handover" button)
 */
export async function submitHandoverToWebhook(payload: any): Promise<{ success: boolean; error?: string }> {
  try {
    console.log('üì§ Submitting handover to webhook:', payload);

    const webhookUrl = import.meta.env.VITE_WEBHOOK_BASE_URL
      ? `${import.meta.env.VITE_WEBHOOK_BASE_URL}/handover-submit`
      : 'https://api.celeste7.ai/webhook/handover-submit';

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Webhook error:', errorText);
      return {
        success: false,
        error: `Webhook returned ${response.status}: ${errorText}`
      };
    }

    const data = await response.json();
    console.log('‚úÖ Handover submitted to webhook:', data);

    return {
      success: true
    };

  } catch (error) {
    console.error('‚ùå Error submitting to webhook:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
